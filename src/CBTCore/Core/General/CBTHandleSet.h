#pragma once

// Include CBT
#include "CBTMacros.h"

// Include STD
#include <vector>

NS_CBT_BEGIN

/**
    \brief
        Generates unique handles of type T.
        Half of the handle will store it's index, and the other half will store it's version.
        For example, a 32bit handle will have it's left 16bits store its version number, and the right 16bits store its index.
        [32bit Handle] = [16bit Version] & [16bit Index]
*/
template <typename T>
class CBTHandleSet
{
protected:
    /// \brief List of all handles, alive & dead.
    std::vector<CBT_ENABLE_IF_UINT(T, T)> m_Handles;
    /// \brief The next index to be recycled.
    CBT_ENABLE_IF_UINT(T, T) m_NextIndex;
    /// \brief Number of handles that can be recycled.
    CBT_ENABLE_IF_UINT(T, T) m_Recycle;

    /// \brief The bitsize of T.
    static const cbtU32 BITSIZE = CBT_BITSIZE(T);
    /// \brief Half the bitsize of T.
    static const cbtU32 HALF_BITSIZE = (CBT_BITSIZE(T)>>1);
    /// \brief A mask to extract the index of a handle.
    static const T INDEX_MASK = (1 << HALF_BITSIZE) - 1;
    /// \brief mask to extract the version of the handle.
    static const T VERSION_MASK = ~INDEX_MASK;

public:
    /**
        \brief Constructor

        \return A CBTHandleSet
    */
    CBTHandleSet()
        : m_NextIndex(0)
        , m_Recycle(0)
    {}
    /**
        \brief Destructor
    */
    virtual ~CBTHandleSet() {}

    /**
        \brief Get a handle given a version and an index.

        \param _version The handle version.
        \param _index The handle index.

        \return Returns a handle given a version and an index.

        \sa GetVersion, GetIndex
    */
    static T GetHandle(cbtU32 _version, cbtU32 _index) { return (_version << HALF_BITSIZE) | (_index & INDEX_MASK); }
    /**
        \brief Get the version number of a given handle.

        \param _handle The handle.

        \return Returns the version number of a given handle.

        \sa GetHandle, GetIndex
    */
    static T GetVersion(T _handle) { return _handle >> HALF_BITSIZE; }
    /**
        \brief Get the index number of a given handle.

        \param _handle The handle.

        \return Returns the index number of a given handle.

        \sa GetVersion, GetIndex
    */
    static T GetIndex(T _handle) { return _handle & INDEX_MASK; }

    /**
        \brief Checks if a handle is still valid. A handle generated by Add is valid until it has been removed by Remove.

        \param _handle The handle.

        \return Returns true if the handle is valid. Otherwise, return false.

        \sa Add, Remove
    */
    cbtBool IsValid(T _handle) const
    {
        T index = GetIndex(_handle);
        if (index >= m_Handles.size()) { return false; }
        return m_Handles[index] == _handle;
    }

    /**
        \brief Generate a new handle.

        \return A newly generated handle.

        \sa IsValid, Remove
    */
    virtual T Add()
    {
        if (m_Recycle == 0)
        {
            T handle = GetHandle(0, (T)m_Handles.size());
            m_Handles.push_back(handle);
            return handle;
        }

        T index = m_NextIndex;
        T version = GetVersion(m_Handles[index]);
        T handle = GetHandle(version, index);
        m_NextIndex = GetIndex(m_Handles[index]);
        m_Handles[index] = handle;
        --m_Recycle;
        return handle;
    }

    /**
        \brief Remove a handle. The handle is now deemed invalid.

        \param _handle The handle to remove.

        \sa IsValid, Add
    */
    virtual void Remove(T _handle)
    {
        if (!IsValid(_handle)) { return; }

        T index = GetIndex(_handle);
        T version = GetVersion(_handle) + 1;
        m_Handles[index] = (version << 16) | m_NextIndex;
        m_NextIndex = index;
        ++m_Recycle;
    }

    /**
        \brief Get the number of valid handles.

        \return The number of valid handles.
    */
    cbtU32 GetHandleCount() const { return static_cast<cbtU32>(m_Handles.size() - m_Recycle); }
};

/// \brief Equivalent to typing CBTHandleSet<__TYPE__>::GetHandle(__VERSION__, __INDEX__)
#define CBT_HANDLE(__TYPE__, __VERSION__, __INDEX__) CBTHandleSet<__TYPE__>::GetHandle(__VERSION__, __INDEX__)
/// \brief Equivalent to typing CBTHandleSet<__TYPE__>::GetIndex(__ENTITY__)
#define CBT_HANDLE_INDEX(__TYPE__, __ENTITY__) CBTHandleSet<__TYPE__>::GetIndex(__ENTITY__)
/// \brief Equivalent to typing CBTHandleSet<__TYPE__>::GetVersion(__ENTITY__)
#define CBT_HANDLE_VERSION(__TYPE__, __ENTITY__) CBTHandleSet<__TYPE__>::GetVersion(__ENTITY__)

NS_CBT_END